name: CI/CD Pipeline

on:
  push:
    branches: [ main, dev ]
  pull_request:
    branches: [ main, dev ]

env:
  AWS_REGION: eu-west-1
  ECR_REPOSITORY_DEV: lead-scoring-api-dev
  ECR_REPOSITORY_PROD: lead-scoring-api-prod
  MIN_COVERAGE: 75
  MAX_SECURITY_ISSUES: 0

jobs:
  quality-gates:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      coverage: ${{ steps.coverage.outputs.coverage }}
      security-issues: ${{ steps.security.outputs.issues }}
      quality-passed: ${{ steps.quality-check.outputs.passed }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'

    - name: Install uv
      uses: astral-sh/setup-uv@v3

    - name: Install dependencies
      run: |
        uv sync --dev

    - name: Generate version
      id: version
      run: |
        if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          # Get latest tag and increment patch version
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          VERSION=$(echo $LATEST_TAG | sed 's/v//' | awk -F. '{$NF = $NF + 1;} 1' | sed 's/ /./g')
          echo "version=v${VERSION}" >> $GITHUB_OUTPUT
        else
          # Use branch name with commit SHA for non-main branches
          COMMIT_SHA=$(git rev-parse --short HEAD)
          echo "version=${GITHUB_REF_NAME}-${COMMIT_SHA}" >> $GITHUB_OUTPUT
        fi

    - name: Run linting
      run: |
        echo "üîç Running code quality checks..."
        uv run black --check app/ tests/ --diff
        uv run ruff check app/ tests/ --output-format=github
        echo "‚úÖ Linting passed"

    - name: Run type checking
      run: |
        echo "üîç Running type checking..."
        uv run mypy app/ --show-error-codes
        echo "‚úÖ Type checking passed"

    - name: Run security scan
      id: security
      run: |
        echo "üîí Running security scan..."
        uv run bandit -r app/ -f json -o security-report.json
        
        # Count high/medium severity issues
        ISSUES=$(jq '.results | length' security-report.json 2>/dev/null || echo "0")
        echo "issues=${ISSUES}" >> $GITHUB_OUTPUT
        echo "Found ${ISSUES} security issues"
        
        if [ "$ISSUES" -gt "${{ env.MAX_SECURITY_ISSUES }}" ]; then
          echo "‚ùå Security scan failed: ${ISSUES} issues found (max: ${{ env.MAX_SECURITY_ISSUES }})"
          exit 1
        fi
        echo "‚úÖ Security scan passed"

    - name: Run tests with coverage
      id: coverage
      run: |
        echo "üß™ Running tests with coverage..."
        uv run pytest tests/ -v \
          --cov=app \
          --cov-report=term-missing \
          --cov-report=xml \
          --cov-report=html \
          --junitxml=pytest-results.xml
        
        # Extract coverage percentage
        COVERAGE=$(python -c "import xml.etree.ElementTree as ET; tree = ET.parse('coverage.xml'); root = tree.getroot(); print(f\"{float(root.attrib['line-rate']) * 100:.1f}\")")
        echo "coverage=${COVERAGE}" >> $GITHUB_OUTPUT
        echo "Code coverage: ${COVERAGE}%"
        
        if (( $(echo "${COVERAGE} < ${{ env.MIN_COVERAGE }}" | bc -l) )); then
          echo "‚ùå Coverage failed: ${COVERAGE}% (required: ${{ env.MIN_COVERAGE }}%)"
          exit 1
        fi
        echo "‚úÖ Coverage passed: ${COVERAGE}%"

    - name: Quality gate check
      id: quality-check
      run: |
        echo "üéØ Quality Gates Summary:"
        echo "‚Ä¢ Coverage: ${{ steps.coverage.outputs.coverage }}% (min: ${{ env.MIN_COVERAGE }}%)"
        echo "‚Ä¢ Security Issues: ${{ steps.security.outputs.security-issues }} (max: ${{ env.MAX_SECURITY_ISSUES }})"
        echo "‚Ä¢ Linting: ‚úÖ Passed"
        echo "‚Ä¢ Type Checking: ‚úÖ Passed"
        echo "passed=true" >> $GITHUB_OUTPUT
        echo "üéâ All quality gates passed!"

    - name: Upload test results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: test-results
        path: |
          pytest-results.xml
          coverage.xml
          htmlcov/
          security-report.json
        retention-days: 1


  vulnerability-scan:
    runs-on: ubuntu-latest
    permissions:
      security-events: write
      actions: read
      contents: read
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: 'trivy-results.sarif'

  build-and-push-dev:
    needs: [quality-gates, vulnerability-scan]
    runs-on: ubuntu-latest
    if: |
      github.ref == 'refs/heads/dev' && 
      needs.quality-gates.outputs.quality-passed == 'true'
    permissions:
      contents: write
      id-token: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build, tag, and push to DEV ECR
      env:
        IMAGE_TAG: ${{ needs.quality-gates.outputs.version }}
      run: |
        echo "üê≥ Building and pushing Docker image to DEV..."
        
        # Build and push with version and latest tags to DEV repo
        ECR_REGISTRY="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
        docker buildx build \
          --platform linux/amd64 \
          --tag ${ECR_REGISTRY}/${{ env.ECR_REPOSITORY_DEV }}:$IMAGE_TAG \
          --tag ${ECR_REGISTRY}/${{ env.ECR_REPOSITORY_DEV }}:latest \
          --push .
        
        echo "‚úÖ DEV Image pushed successfully:"
        echo "‚Ä¢ ${ECR_REGISTRY}/${{ env.ECR_REPOSITORY_DEV }}:$IMAGE_TAG"
        echo "‚Ä¢ ${ECR_REGISTRY}/${{ env.ECR_REPOSITORY_DEV }}:latest"

    - name: Update DEV ECS Task Definition and Service
      env:
        IMAGE_TAG: ${{ needs.quality-gates.outputs.version }}
      run: |
        echo "üöÄ Updating DEV ECS task definition and restarting service..."
        
        ECR_REGISTRY="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
        NEW_IMAGE="${ECR_REGISTRY}/${{ env.ECR_REPOSITORY_DEV }}:latest"
        
        # Get current task definition
        CURRENT_TASK_DEF=$(aws ecs describe-task-definition \
          --task-definition lead-scoring-dev \
          --region ${{ env.AWS_REGION }} \
          --query 'taskDefinition' \
          --output json)
        
        # Update the image in task definition
        NEW_TASK_DEF=$(echo $CURRENT_TASK_DEF | jq --arg IMAGE "$NEW_IMAGE" '
          .containerDefinitions[0].image = $IMAGE |
          del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy, .enableFaultInjection, .tags)
        ')
        
        # Register new task definition
        NEW_TASK_DEF_ARN=$(echo $NEW_TASK_DEF | aws ecs register-task-definition \
          --region ${{ env.AWS_REGION }} \
          --cli-input-json file:///dev/stdin \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text)
        
        echo "‚úÖ New task definition registered: $NEW_TASK_DEF_ARN"
        
        # Force restart the service to use new task definition
        aws ecs update-service \
          --cluster marketing-cluster \
          --service lead-scoring-dev-service \
          --task-definition $NEW_TASK_DEF_ARN \
          --force-new-deployment \
          --region ${{ env.AWS_REGION }}
        
        echo "üîÑ Service restart initiated..."
        
        # Wait for service to stabilize
        echo "‚è≥ Waiting for service to stabilize..."
        aws ecs wait services-stable \
          --cluster marketing-cluster \
          --services lead-scoring-dev-service \
          --region ${{ env.AWS_REGION }}
        
        echo "‚úÖ DEV deployment completed successfully!"

  build-and-push-prod:
    needs: [quality-gates, vulnerability-scan]
    runs-on: ubuntu-latest
    if: |
      github.ref == 'refs/heads/main' && 
      needs.quality-gates.outputs.quality-passed == 'true'
    permissions:
      contents: write
      id-token: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        role-to-assume: ${{ secrets.AWS_ROLE_ARN }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build, tag, and push to PROD ECR
      env:
        IMAGE_TAG: ${{ needs.quality-gates.outputs.version }}
      run: |
        echo "üê≥ Building and pushing Docker image to PROD..."
        
        # Build and push with version tag to PROD repo
        ECR_REGISTRY="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
        docker buildx build \
          --platform linux/amd64 \
          --tag ${ECR_REGISTRY}/${{ env.ECR_REPOSITORY_PROD }}:$IMAGE_TAG \
          --push .
        
        echo "‚úÖ PROD Image pushed successfully:"
        echo "‚Ä¢ ${ECR_REGISTRY}/${{ env.ECR_REPOSITORY_PROD }}:$IMAGE_TAG"
        
        # Output for deployment job
        echo "image=${ECR_REGISTRY}/${{ env.ECR_REPOSITORY_PROD }}:$IMAGE_TAG" >> $GITHUB_OUTPUT

    - name: Create and push Git tag
      env:
        VERSION: ${{ needs.quality-gates.outputs.version }}
      run: |
        echo "üè∑Ô∏è Creating Git tag: $VERSION"
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git tag -a $VERSION -m "Release $VERSION - Coverage: ${{ needs.quality-gates.outputs.coverage }}%"
        git push origin $VERSION

    - name: Scan image for vulnerabilities
      env:
        IMAGE_TAG: ${{ needs.quality-gates.outputs.version }}
      run: |
        echo "üîí Scanning image for vulnerabilities..."
        
        # Wait for ECR scan to complete
        aws ecr start-image-scan --repository-name ${{ env.ECR_REPOSITORY_PROD }} --image-id imageTag=$IMAGE_TAG || true
        sleep 30
        
        # Check scan results
        SCAN_RESULTS=$(aws ecr describe-image-scan-findings --repository-name ${{ env.ECR_REPOSITORY_PROD }} --image-id imageTag=$IMAGE_TAG --query 'imageScanFindings.findingCounts' --output json 2>/dev/null || echo '{}')
        
        CRITICAL=$(echo $SCAN_RESULTS | jq -r '.CRITICAL // 0')
        HIGH=$(echo $SCAN_RESULTS | jq -r '.HIGH // 0')
        
        echo "Vulnerability scan results:"
        echo "‚Ä¢ Critical: $CRITICAL"
        echo "‚Ä¢ High: $HIGH"
        
        if [ "$CRITICAL" -gt "0" ] || [ "$HIGH" -gt "3" ]; then
          echo "‚ùå Image vulnerability scan failed"
          exit 1
        fi
        echo "‚úÖ Image vulnerability scan passed"

    - name: Update PROD ECS Task Definition and Service
      env:
        IMAGE_TAG: ${{ needs.quality-gates.outputs.version }}
      run: |
        echo "üöÄ Updating PROD ECS task definition and restarting service..."
        
        ECR_REGISTRY="${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com"
        NEW_IMAGE="${ECR_REGISTRY}/${{ env.ECR_REPOSITORY_PROD }}:$IMAGE_TAG"
        
        # Get current task definition
        CURRENT_TASK_DEF=$(aws ecs describe-task-definition \
          --task-definition lead-scoring-prod \
          --region ${{ env.AWS_REGION }} \
          --query 'taskDefinition' \
          --output json)
        
        # Update the image in task definition
        NEW_TASK_DEF=$(echo $CURRENT_TASK_DEF | jq --arg IMAGE "$NEW_IMAGE" '
          .containerDefinitions[0].image = $IMAGE |
          del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy, .enableFaultInjection, .tags)
        ')
        
        # Register new task definition
        NEW_TASK_DEF_ARN=$(echo $NEW_TASK_DEF | aws ecs register-task-definition \
          --region ${{ env.AWS_REGION }} \
          --cli-input-json file:///dev/stdin \
          --query 'taskDefinition.taskDefinitionArn' \
          --output text)
        
        echo "‚úÖ New task definition registered: $NEW_TASK_DEF_ARN"
        
        # Force restart the service to use new task definition
        aws ecs update-service \
          --cluster marketing-cluster \
          --service lead-scoring-prod-service \
          --task-definition $NEW_TASK_DEF_ARN \
          --force-new-deployment \
          --region ${{ env.AWS_REGION }}
        
        echo "üîÑ Service restart initiated..."
        
        # Wait for service to stabilize
        echo "‚è≥ Waiting for service to stabilize..."
        aws ecs wait services-stable \
          --cluster marketing-cluster \
          --services lead-scoring-prod-service \
          --region ${{ env.AWS_REGION }}
        
        echo "üéâ Production deployment completed successfully!"
